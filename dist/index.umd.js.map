{"version":3,"file":"index.umd.js","sources":["../src/index.ts"],"sourcesContent":["const OK = 0;\r\nconst DATA_ERROR = -3;\r\n\r\nclass Tree {\r\n\t/**table of code length counts */\r\n\ttable = new Uint16Array(16);\r\n\t/**code -> symbol translation table */\r\n\ttrans = new Uint16Array(288);\r\n}\r\n\r\nclass Data {\r\n\tsourceIndex = 0;\r\n\ttag = 0;\r\n\tbitCount = 0;\r\n\tdestLen = 0;\r\n\t/** dynamic length/symbol tree */\r\n\tlengthTree = new Tree();\r\n\t/** dynamic distance tree */\r\n\tdistanceTree = new Tree();\r\n\tsource: Buffer | Uint8Array;\r\n\tdest: Buffer | Uint8Array;\r\n\r\n\tconstructor(\r\n\t\tsource: Buffer | Uint8Array,\r\n\t\tdest: Buffer | Uint8Array\r\n\t) {\r\n\t\tthis.source = source;\r\n\t\tthis.dest = dest;\r\n\t}\r\n}\r\n\r\n/*-------------------------------------------------------*\r\n *---- uninitialized global data (static structures) ----*\r\n *-------------------------------------------------------*/\r\n\r\nconst staticLengthTree = new Tree();\r\nconst staticDistanceTree = new Tree();\r\n\r\n/* extra bits and base tables for length codes */\r\nconst length_bits = new Uint8Array(30);\r\nconst length_base = new Uint16Array(30);\r\n\r\n/* extra bits and base tables for distance codes */\r\nconst dist_bits = new Uint8Array(30);\r\nconst dist_base = new Uint16Array(30);\r\n\r\n/* special ordering of code length codes */\r\nconst clcidx = new Uint8Array([\r\n\t16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,\r\n]);\r\n\r\n/* used by tinf_decode_trees, avoids allocations every call */\r\nconst code_tree = new Tree();\r\nconst lengths = new Uint8Array(288 + 32);\r\n\r\n/* --------------------------- *\r\n * ---- utility functions ---- *\r\n * --------------------------- */\r\n\r\n/** build extra bits and base tables */\r\nfunction buildBitAndBaseTables(\r\n\tbits: Uint8Array,\r\n\tbase: Uint16Array,\r\n\tdelta: number,\r\n\tfirst: number\r\n) {\r\n\t/* build bits table */\r\n\tfor (let i = 0; i < delta; ++i) bits[i] = 0;\r\n\tfor (let i = 0; i < 30 - delta; ++i)\r\n\t\tbits[i + delta] = (i / delta) | 0;\r\n\r\n\t/* build base table */\r\n\tfor (let i = 0, sum = first; i < 30; ++i) {\r\n\t\tbase[i] = sum;\r\n\t\tsum += 1 << bits[i];\r\n\t}\r\n}\r\n\r\n/**build the fixed huffman trees*/\r\nfunction tinf_build_fixed_trees(\r\n\tlengthTree: Tree,\r\n\tdistanceTree: Tree\r\n) {\r\n\tlet i = 0;\r\n\r\n\t/* build fixed length tree */\r\n\tfor (i = 0; i < 7; ++i) lengthTree.table[i] = 0;\r\n\r\n\tlengthTree.table[7] = 24;\r\n\tlengthTree.table[8] = 152;\r\n\tlengthTree.table[9] = 112;\r\n\r\n\tfor (i = 0; i < 24; ++i) lengthTree.trans[i] = 256 + i;\r\n\tfor (i = 0; i < 144; ++i) lengthTree.trans[24 + i] = i;\r\n\tfor (i = 0; i < 8; ++i) lengthTree.trans[24 + 144 + i] = 280 + i;\r\n\tfor (i = 0; i < 112; ++i)\r\n\t\tlengthTree.trans[24 + 144 + 8 + i] = 144 + i;\r\n\r\n\t/* build fixed distance tree */\r\n\tfor (i = 0; i < 5; ++i) distanceTree.table[i] = 0;\r\n\r\n\tdistanceTree.table[5] = 32;\r\n\r\n\tfor (i = 0; i < 32; ++i) distanceTree.trans[i] = i;\r\n}\r\n\r\n/* given an array of code lengths, build a tree */\r\nconst offsets = new Uint16Array(16);\r\n\r\nfunction tinf_build_tree(\r\n\ttree: Tree,\r\n\tlengths: Uint8Array,\r\n\toffset: number,\r\n\tnum: number\r\n) {\r\n\tlet i, sum;\r\n\r\n\t/* clear code length count table */\r\n\tfor (i = 0; i < 16; ++i) tree.table[i] = 0;\r\n\r\n\t/* scan symbol lengths, and sum code length counts */\r\n\tfor (i = 0; i < num; ++i) tree.table[lengths[offset + i]]++;\r\n\r\n\ttree.table[0] = 0;\r\n\r\n\t/* compute offset table for distribution sort */\r\n\tfor (sum = 0, i = 0; i < 16; ++i) {\r\n\t\toffsets[i] = sum;\r\n\t\tsum += tree.table[i];\r\n\t}\r\n\r\n\t/* create code->symbol translation table (symbols sorted by code) */\r\n\tfor (i = 0; i < num; ++i) {\r\n\t\tif (lengths[offset + i])\r\n\t\t\ttree.trans[offsets[lengths[offset + i]]++] = i;\r\n\t}\r\n}\r\n\r\n/* -------------------------- *\r\n * ---- decode functions ---- *\r\n * -------------------------- */\r\n\r\n/**get one bit from source stream */\r\nfunction getNextBit(d: Data) {\r\n\t/* check if tag is empty */\r\n\tif (!d.bitCount--) {\r\n\t\t/* load next tag */\r\n\t\td.tag = d.source[d.sourceIndex++];\r\n\t\td.bitCount = 7;\r\n\t}\r\n\r\n\t/* shift bit out of tag */\r\n\tconst bit = d.tag & 1;\r\n\td.tag >>>= 1;\r\n\r\n\treturn bit;\r\n}\r\n\r\n/** read a num bit value from a stream and add base */\r\nfunction readBits(d: Data, num: number, base: number) {\r\n\tif (!num) return base;\r\n\r\n\twhile (d.bitCount < 24) {\r\n\t\td.tag |= d.source[d.sourceIndex++] << d.bitCount;\r\n\t\td.bitCount += 8;\r\n\t}\r\n\r\n\tconst val = d.tag & (0xffff >>> (16 - num));\r\n\td.tag >>>= num;\r\n\td.bitCount -= num;\r\n\treturn val + base;\r\n}\r\n\r\n/** given a data stream and a tree, decode a symbol */\r\nfunction decodeSymbols(d: Data, t: Tree) {\r\n\twhile (d.bitCount < 24) {\r\n\t\td.tag |= d.source[d.sourceIndex++] << d.bitCount;\r\n\t\td.bitCount += 8;\r\n\t}\r\n\r\n\tlet sum = 0,\r\n\t\tcur = 0,\r\n\t\tlen = 0;\r\n\tlet tag = d.tag;\r\n\r\n\t/* get more bits while code value is above sum */\r\n\tdo {\r\n\t\tcur = 2 * cur + (tag & 1);\r\n\t\ttag >>>= 1;\r\n\t\t++len;\r\n\r\n\t\tsum += t.table[len];\r\n\t\tcur -= t.table[len];\r\n\t} while (cur >= 0);\r\n\r\n\td.tag = tag;\r\n\td.bitCount -= len;\r\n\r\n\treturn t.trans[sum + cur];\r\n}\r\n\r\n/* given a data stream, decode dynamic trees from it */\r\nfunction tinf_decode_trees(\r\n\tdata: Data,\r\n\tlengthTree: Tree,\r\n\tdistanceTree: Tree\r\n) {\r\n\tlet i, num, length;\r\n\r\n\t/* get 5 bits HLIT (257-286) */\r\n\tconst hlit = readBits(data, 5, 257);\r\n\r\n\t/* get 5 bits HDIST (1-32) */\r\n\tconst hdist = readBits(data, 5, 1);\r\n\r\n\t/* get 4 bits HCLEN (4-19) */\r\n\tconst hclen = readBits(data, 4, 4);\r\n\r\n\tfor (i = 0; i < 19; ++i) lengths[i] = 0;\r\n\r\n\t/* read code lengths for code length alphabet */\r\n\tfor (i = 0; i < hclen; ++i) {\r\n\t\t/* get 3 bits code length (0-7) */\r\n\t\tconst codeLength = readBits(data, 3, 0);\r\n\t\tlengths[clcidx[i]] = codeLength;\r\n\t}\r\n\r\n\t/* build code length tree */\r\n\ttinf_build_tree(code_tree, lengths, 0, 19);\r\n\r\n\t/* decode code lengths for the dynamic trees */\r\n\tfor (num = 0; num < hlit + hdist; ) {\r\n\t\tconst sym = decodeSymbols(data, code_tree);\r\n\r\n\t\tswitch (sym) {\r\n\t\t\tcase 16: {\r\n\t\t\t\t/* copy previous code length 3-6 times (read 2 bits) */\r\n\t\t\t\tconst prev = lengths[num - 1];\r\n\t\t\t\tfor (\r\n\t\t\t\t\tlength = readBits(data, 2, 3);\r\n\t\t\t\t\tlength;\r\n\t\t\t\t\t--length\r\n\t\t\t\t) {\r\n\t\t\t\t\tlengths[num++] = prev;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 17: {\r\n\t\t\t\t/* repeat code length 0 for 3-10 times (read 3 bits) */\r\n\t\t\t\tfor (\r\n\t\t\t\t\tlength = readBits(data, 3, 3);\r\n\t\t\t\t\tlength;\r\n\t\t\t\t\t--length\r\n\t\t\t\t) {\r\n\t\t\t\t\tlengths[num++] = 0;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 18: {\r\n\t\t\t\t/* repeat code length 0 for 11-138 times (read 7 bits) */\r\n\t\t\t\tfor (\r\n\t\t\t\t\tlength = readBits(data, 7, 11);\r\n\t\t\t\t\tlength;\r\n\t\t\t\t\t--length\r\n\t\t\t\t) {\r\n\t\t\t\t\tlengths[num++] = 0;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tdefault: {\r\n\t\t\t\t/* values 0-15 represent the actual code lengths */\r\n\t\t\t\tlengths[num++] = sym;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/* build dynamic trees */\r\n\ttinf_build_tree(lengthTree, lengths, 0, hlit);\r\n\ttinf_build_tree(distanceTree, lengths, hlit, hdist);\r\n}\r\n\r\n/* ----------------------------- *\r\n * -- block inflate functions -- *\r\n * ----------------------------- */\r\n/* given a stream and two trees, inflate a block of data */\r\nfunction tinf_inflate_block_data(\r\n\tdata: Data,\r\n\tlengthTree: Tree,\r\n\tdistanceTree: Tree\r\n) {\r\n\tlet sym = decodeSymbols(data, lengthTree);\r\n\twhile (sym !== 256) {\r\n\t\tif (sym < 256) {\r\n\t\t\tdata.dest[data.destLen++] = sym;\r\n\t\t} else {\r\n\t\t\tlet i;\r\n\r\n\t\t\tsym -= 257;\r\n\r\n\t\t\t/* possibly get more bits from length code */\r\n\t\t\tconst length = readBits(\r\n\t\t\t\tdata,\r\n\t\t\t\tlength_bits[sym],\r\n\t\t\t\tlength_base[sym]\r\n\t\t\t);\r\n\r\n\t\t\tconst dist = decodeSymbols(data, distanceTree);\r\n\r\n\t\t\t/* possibly get more bits from distance code */\r\n\t\t\tconst offsets =\r\n\t\t\t\tdata.destLen -\r\n\t\t\t\treadBits(data, dist_bits[dist], dist_base[dist]);\r\n\r\n\t\t\t/* copy match */\r\n\t\t\tfor (i = offsets; i < offsets + length; ++i) {\r\n\t\t\t\tdata.dest[data.destLen++] = data.dest[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\tsym = decodeSymbols(data, lengthTree);\r\n\t}\r\n\treturn OK;\r\n}\r\n\r\n/* inflate an uncompressed block of data */\r\n/**\r\n * @param {Data} d\r\n */\r\nfunction inflateUncompressedBlock(d: Data) {\r\n\tlet length, lengthComplement;\r\n\r\n\t/* unread from bitbuffer */\r\n\twhile (d.bitCount > 8) {\r\n\t\td.sourceIndex--;\r\n\t\td.bitCount -= 8;\r\n\t}\r\n\r\n\t/* get length */\r\n\tlength = d.source[d.sourceIndex + 1];\r\n\tlength = 256 * length + d.source[d.sourceIndex];\r\n\r\n\t/* get one's complement of length */\r\n\tlengthComplement = d.source[d.sourceIndex + 3];\r\n\tlengthComplement =\r\n\t\t256 * lengthComplement + d.source[d.sourceIndex + 2];\r\n\r\n\t/* check length */\r\n\tif (length !== (~lengthComplement & 0x0000ffff))\r\n\t\treturn DATA_ERROR;\r\n\r\n\td.sourceIndex += 4;\r\n\r\n\t/* copy block */\r\n\tfor (let i = length; i; --i)\r\n\t\td.dest[d.destLen++] = d.source[d.sourceIndex++];\r\n\r\n\t/* make sure we start next block on a byte boundary */\r\n\td.bitCount = 0;\r\n\r\n\treturn OK;\r\n}\r\n\r\n/* inflate stream from source to dest */\r\nfunction inflate(\r\n\tsource: Buffer | Uint8Array,\r\n\tdest: Buffer | Uint8Array\r\n): Buffer | Uint8Array {\r\n\tconst d = new Data(source, dest);\r\n\tlet bitFinal: number, bitType: number, result: number;\r\n\r\n\tdo {\r\n\t\t/* read final block flag */\r\n\t\tbitFinal = getNextBit(d);\r\n\r\n\t\t/* read block type (2 bits) */\r\n\t\tbitType = readBits(d, 2, 0);\r\n\r\n\t\t/* decompress block */\r\n\t\tswitch (bitType) {\r\n\t\t\tcase 0:\r\n\t\t\t\t/* decompress uncompressed block */\r\n\t\t\t\tresult = inflateUncompressedBlock(d);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 1:\r\n\t\t\t\t/* decompress block with fixed huffman trees */\r\n\t\t\t\tresult =\r\n\t\t\t\t\ttinf_inflate_block_data(\r\n\t\t\t\t\t\td,\r\n\t\t\t\t\t\tstaticLengthTree,\r\n\t\t\t\t\t\tstaticDistanceTree\r\n\t\t\t\t\t) || 0;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\t/* decompress block with dynamic huffman trees */\r\n\t\t\t\ttinf_decode_trees(d, d.lengthTree, d.distanceTree);\r\n\t\t\t\tresult =\r\n\t\t\t\t\ttinf_inflate_block_data(\r\n\t\t\t\t\t\td,\r\n\t\t\t\t\t\td.lengthTree,\r\n\t\t\t\t\t\td.distanceTree\r\n\t\t\t\t\t) || 0;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tresult = DATA_ERROR;\r\n\t\t}\r\n\r\n\t\tif (result !== OK) throw new Error('Data error');\r\n\t} while (!bitFinal);\r\n\r\n\tif (d.destLen < d.dest.length) {\r\n\t\tif (typeof d.dest.slice === 'function')\r\n\t\t\treturn d.dest.slice(0, d.destLen);\r\n\t\telse return d.dest.subarray(0, d.destLen);\r\n\t}\r\n\r\n\treturn d.dest;\r\n}\r\n\r\n/* ------------------------ *\r\n * ---- initialization ---- *\r\n * ------------------------ */\r\n\r\n/* build fixed huffman trees */\r\ntinf_build_fixed_trees(staticLengthTree, staticDistanceTree);\r\n\r\n/* build extra bits and base tables */\r\nbuildBitAndBaseTables(length_bits, length_base, 4, 3);\r\nbuildBitAndBaseTables(dist_bits, dist_base, 2, 1);\r\n\r\n/* fix a special case */\r\nlength_bits[28] = 0;\r\nlength_base[28] = 258;\r\n\r\nexport default inflate;\r\n"],"names":["Tree","table","Uint16Array","trans","Data","source","dest","sourceIndex","tag","bitCount","destLen","lengthTree","distanceTree","this","staticLengthTree","staticDistanceTree","length_bits","Uint8Array","length_base","dist_bits","dist_base","clcidx","code_tree","lengths","buildBitAndBaseTables","bits","base","delta","first","i","sum","offsets","tinf_build_tree","tree","offset","num","getNextBit","d","bit","readBits","val","decodeSymbols","t","cur","len","tinf_decode_trees","data","length","hlit","hdist","hclen","codeLength","sym","prev","tinf_inflate_block_data","dist","inflateUncompressedBlock","tinf_build_fixed_trees","bitFinal","result","Error","slice","subarray"],"mappings":"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"}